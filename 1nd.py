"""
Automatically generated by Colab.
Original file is located at: https://colab.research.google.com/drive/1HzBb4FYttMBjvl8IxG0xqJMbaQgx9PfW?usp=sharing
"""

#!pip install deepface

# Įkeliamos visos reikalingos bibliotekos
from PIL import Image
from IPython.display import display
from google.colab import files
import cv2
import numpy as np
from deepface import DeepFace

# Nuotraukos įkėlimas iš kompiuterio
def upload_image():
    uploaded = files.upload()
    img_name = list(uploaded.keys())[0]
    return img_name

# Veido aptikimas pagal specifinį veidą naudojant DeepFace (ArcFace modelį)
# Kitiems veidams taikomas blur efektas
def identify_and_blur_faces(img_path, reference_face_path):
    # Nuotraukų išgavimas
    img_cv2 = cv2.imread(img_path)
    reference_cv2 = cv2.imread(reference_face_path)

    # Įkeltų nuotraukų atvaizdavimas
    uploaded_image = Image.open(img_path)
    uploaded_image.thumbnail((400, 400))  # Sumažinami įkeltų nuotraukų dydžiai dėl patogesnio matomumo
    display(uploaded_image)
    reference_image = Image.open(reference_face_path)
    reference_image.thumbnail((200, 200))
    display(reference_image)

    # Veidų aptikimas
    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml') # Įkeliamas Haar kaskadas veidų aptikimui
    gray = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2GRAY) # Konvertuojamas spalvotas vaizdas į pilką (būtina veidų aptikimui; BGR dėl OpenCV)
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=7, minSize=(30, 30))

    best_match_index = None
    lowest_distance = float("inf")

    # Aptikto veido nustatymas pagal specifinį
    for i, (x, y, w, h) in enumerate(faces):
        face_roi = img_cv2[y:y+h, x:x+w] # Gautas veido regionas
        try:
            result = DeepFace.verify(face_roi, reference_cv2, model_name='ArcFace', enforce_detection=False) # Naudojamas ArcFace modelis
            distance = result['distance'] # Gaunamas atstumas tarp veidų (kuo mažesnis, tuo geresnis sutapimas)

            if distance < lowest_distance:
                lowest_distance = distance
                best_match_index = i
        except:
            continue # Jei įvyksta klaida, praleidžiamas esamas veidas

    # Blur efekto pritaikymas visiems kitiems veidams
    for i, (x, y, w, h) in enumerate(faces):
        if i != best_match_index:
            face_region = img_cv2[y:y+h, x:x+w]
            blurred_face = cv2.GaussianBlur(face_region, (99, 99), 30)
            img_cv2[y:y+h, x:x+w] = blurred_face

    # Sutapusio veido apibrėžimas
    if best_match_index is not None:
        x, y, w, h = faces[best_match_index]
        cv2.rectangle(img_cv2, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # Spalvų gražinimas atvaizdavimui
    img_rgb = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2RGB)

    display(Image.fromarray(img_rgb)) # Atvaizduojamas galutinis rezultatas


if __name__ == "__main__":
    print("Įkelkite nuotrauką su žmonėmis:")
    img_path = upload_image()
    print("Įkelkite specifinio žmogaus veido nuotrauką:")
    reference_face_path = upload_image()
    identify_and_blur_faces(img_path, reference_face_path)